import { Markdown } from '../../components/Page';
import { ComingSoon } from '../../components/ComingSoon';

# Virtual Fields

Keystone lets you define your data model in terms of `lists`, which have `fields`.
Most lists will have some [scalar fields](../apis/fields#scalar-types), such as `text` and `integer` fields, which are stored in your database.

It can also be helpful to have read-only fields which are computed on the fly when you query them.
Keystone lets you do this with the `virtual` field type.

Virtual fields provide a powerful way to extend your GraphQL API.
In this guide we'll introduce the syntax for adding virtual fields, and show how to build up from a simple to a complex example.

## Hello world

We'll start with a list called `Example` and create a virtual field called `hello`.

```typescript
import { config, createSchema, list } from '@keystone-next/keystone/schema';
import { virtual } from '@keystone-next/fields';

export default config({
  lists: createSchema({
    Example: list({
      fields: {
        hello: virtual({
          field: schema.field({
            type: schema.String,
            resolve() {
              return "Hello, world!";
            },
          }),
        }),
      },
    }),
  }),
});
```

We can now run a GraphQL query and request the `hello` field on one of our `Example` items,

```graphql
{
  Example(id: "1") {
    id
    hello
  }
}
```

which gives the response:

```javascript
{ Example: { id: "1", hello: "Hello, world! } }
```

The value of `hello` is generated from the `resolve` function, which returns the string `"Hello, world!"`.

## The schema API

The `virtual` field is configured using functions from the `schema` API in the `@keystone-next/types` package.
This API provides the interface required to create type-safe extensions to the Keystone GraphQL schema.

The `virtual` field accepts a configuration option called `field`, which is a `schema.field()` object.

In our example we passed in two required options to `schema.field()`.
The option `type: schema.String` specifies the GraphQL type of our virtual field, and `resolve() { ... }` defines the [GraphQL resolver](https://graphql.org/learn/execution/#root-fields-resolvers) to be executed when this field is queried.

We can use `schema.field()` to build up more powerful virtual fields which accept arguments, and return more complex types.

## Resolver arguments

The `resolve` function accepts arguments which let you write more sophisticated virtual fields.
The arguments are `(item, args, context, info)`.
The `item` argument is the **internal item** representing the list item being queried.
Refer to the [internal items guide](../guides/internal-items) for details on how to work with internal items in Keystone.
The `args` argument represents the arguments passed to the field itself in the query.
The `context` argument is a [`KeystoneContext`](./apis/context) object.
The `info` argument holds field-specific information relevant to the current query as well as the schema details.

We can use the `item` and `context` arguments to query data in our Keystone system.
For example, if have a blog with `Author` and `Post` lists, it might be convenient to have an `authorName` field on the `Post` list.
We can do this with a `virtual` field which queries for the related `author` and returns their name.

```typescript
export default config({
  lists: createSchema({
    Post: list({
      fields: {
        content: text(),
        author: relationship({ ref: 'Author', many: false }),
        authorName: virtual({
          field: schema.field({
            async resolve(item, args, context) {
              const { author } = await context.lists.Post.findOne({
                where: { id: item.id },
                query: 'author { name }',
              });
              return author && author.name;
            },
          }),
        }),
      },
    }),
    Author: list({
      fields: {
        name: text({ isRequired: true }),
      },
    }),
  }),
});
```

## GraphQL arguments

Continuing with our blog example, we may want to extract an excerpt of each blog post for display on the home page.
We could query the full `Post.content` field for each post and then slice it in the client, but it would be nicer if we could ask for just the slice that we want from the GraphQL API.

To do this we can use a `virtual` field which takes a `length` argument and then performs the `.slice()` operation as part of resolver function.
We use the `args` option to define the GraphQL field arguments we want to support.

```typescript
export default config({
  lists: createSchema({
    Post: list({
      fields: {
        content: text(),
        excerpt: virtual({
          field: schema.field({
            type: schema.String,
            args: {
              length: schema.arg({
                type: schema.nonNull(schema.Int),
                defaultValue: 200
              }),
            },
            resolve(item, args) {
              if (!item.content) {
                return null;
              }
              return item.content.slice(0, args.length - 3) + '...';
            },
          }),
        }),
      },
    }),
  }),
});
```

This will generate the following GraphQL type:

```graphql
type Post {
  id: ID!
  content: String
  excerpt(length: Int! = 200): String
}
```

We can now perform the following query to get all the excerpts without over-fetching on the client.

```
{
  allPosts {
    id
    excerpt(length: 100)
  }
}
```

## GraphQL Objects

If you return an object type, you will need to provide `graphQLReturnFragment` so that the Admin UI knows what to fetch.

```ts
import { schema } from '@keystone-next/types';
import { virtual } from '@keystone-next/fields';
import { list } from '@keystone-next/keystone/schema';

list({
  fields: {
    something: virtual({
      field: schema.field({
        type: schema.object<{ a: string; b: string }>()({
          name: 'Something',
          fields: {
            a: schema.field({ type: schema.String }),
            b: schema.field({ type: schema.String }),
          },
        }),
        resolve() {
          return { a: 'something', b: 'another thing' };
        },
      }),
      graphQLReturnFragment: '{ a, b }',
    }),
  },
});
```

## GraphQL Types

### Scalars

GraphQL scalars are available on `schema.`

GraphQL has a set of built-in scalars:

- `Int`
- `Float`
- `String`
- `Boolean`
- `ID`

Keystone also includes some custom scalars that you can use:

- `Upload`
- `JSON`

### Output Objects

To create an object type, you can use `schema.object`.

When calling `schema.object`, you must provide a type parameter that is the root value of the object type.
The root value what you receive as the first argument of resolvers on this type and what you must return from resolvers of fields that return this type.

```ts
const Person = schema.object<{ name: string }>()({
  name: "Person",
  fields: {
    name: schema.field({ type: schema.String }),
  },
});
// ==
graphql`
  type Person {
    name: String
  }
`;
```

#### Writing resolvers

To do anything other than just return a field from the RootVal, you need to provide a resolver.
Note: TypeScript will force you to provide a resolve function if the field in the RootVal and the GraphQL field don't match. That's why you need to provide a resolver to the field on

```ts
const Person = schema.object<{ name: string }>()({
  name: "Person",
  fields: {
    name: schema.field({ type: schema.String }),
    excitedName: schema.field({
      type: schema.String,
      resolve(rootVal, args, context, info) {
        return `${rootVal.name}!`;
      },
    }),
  },
});
```

## Circularity

GraphQL types will often contain references to themselves and to make TypeScript allow that, you need have an explicit type annotation of `schema.ObjectType<RootVal>` along with making `fields` a function that returns the object.

```ts
type PersonRootVal = { name: string; friends: PersonRootVal[] };

const Person: schema.ObjectType<PersonRootVal> = schema.object<PersonRootVal>()({
  name: "Person",
  fields: () => ({
    name: schema.field({ type: schema.String }),
    friends: schema.field({ type: schema.list(Person) }),
  }),
});
```

## Using GraphQL types from other lists

To use GraphQL types from other lists in a virtual field (e.g. to express a polymorphic relationship), you can provide a function to the virtual field that accepts an object contains the GraphQL types for all the lists and returns the GraphQL field.

```ts
import { schema } from '@keystone-next/types';
import { virtual, text, relationship } from '@keystone-next/fields';
import { list, createSchema } from '@keystone-next/keystone/schema';

createSchema({
  Organisation: list({
    fields: {
      name: text(),
      authoredPosts: relationship({ ref: 'Post.organisationAuthor', many: true }),
    },
  }),
  Person: list({
    fields: {
      name: text(),
      authoredPosts: relationship({ ref: 'Post.personAuthor', many: true }),
    },
  }),
  Post: list({
    fields: {
      organisationAuthor: relationship({ ref: 'Organisation.authoredPosts' }),
      personAuthor: relationship({ ref: 'Person.authoredPosts' }),
      author: virtual({
        field: lists =>
          schema.field({
            type: schema.union({
              name: 'Author',
              types: [lists.Person.types.output, lists.Organisation.types.output],
            }),
            async resolve(rootVal, args, context) {
              const [personAuthors, organisationAuthors] = await Promise.all([
                context.db.lists.Person.findMany({
                  where: { authoredPosts_some: { id: rootVal.id.toString() } },
                }),
                context.db.lists.Organisation.findMany({
                  where: { authoredPosts_some: { id: rootVal.id.toString() } },
                }),
              ]);
              if (personAuthors.length) {
                return { __typename: 'Person', ...personAuthors[0] };
              }
              if (organisationAuthors.length) {
                return { __typename: 'Organisation', ...organisationAuthors[0] };
              }
            },
          }),
      }),
    },
  }),
});
```

export default ({ children }) => <Markdown>{children}</Markdown>;
